// Generated by CoffeeScript 1.4.0
(function() {

  $(function() {
    var Room, room;
    Room = (function() {

      function Room() {
        this.opts = {};
        this.savedOpts = new Array;
        this.defaultOpts = {
          tooltype: 'line',
          color: '#404040',
          defaultWidth: 2,
          currentScale: 1,
          opacity: 1
        };
      }

      Room.prototype.init = function() {
        var canvas;
        this.initOpts();
        $(".toolTypeChanger").on("click", function() {
          return opts.tooltype = $(this).data("tooltype");
        });
        $('#colorSelect .color').click(function() {
          $('#colorSelect .color').removeClass('activen');
          opts.color = $(this).attr('data-color');
          $(this).addClass('activen');
          return $(".colorSelected").css("background", opts.color);
        });
        $(document).on("click", "#canvasSelectDiv a", function() {
          App.room.canvas.selectThumb(this, true);
          return false;
        });
        this.helper.initUploader();
        this.helper.initHotkeys();
        canvas = $("#myCanvas")[0];
        canvas.onselectstart = function() {
          return false;
        };
        canvas.onmousedown = function() {
          return false;
        };
        return false;
      };

      Room.prototype.initOpts = function() {
        this.opts = {};
        window.opts = this.opts;
        $.extend(this.opts, this.defaultOpts);
        this.opts.historytools = {
          eligibleHistory: new Array,
          allHistory: new Array
        };
        return this.savedOpts.push(this.opts);
      };

      Room.prototype.setOpts = function(opts) {
        this.opts = opts;
        return window.opts = opts;
      };

      Room.prototype.onMouseMove = function(canvas, event) {
        var selectedTool;
        event.point = this.applyCurrentScale(event.point);
        canvas.css({
          cursor: "default"
        });
        selectedTool = this.items.selected();
        if (selectedTool && selectedTool.selectionRect) {
          if (selectedTool.selectionRect.bottomRightScaler.bounds.contains(event.point)) {
            return canvas.css({
              cursor: "se-resize"
            });
          } else if (selectedTool.selectionRect.topLeftScaler.bounds.contains(event.point)) {
            return canvas.css({
              cursor: "nw-resize"
            });
          } else if (selectedTool.selectionRect.topRightScaler.bounds.contains(event.point)) {
            return canvas.css({
              cursor: "ne-resize"
            });
          } else if (selectedTool.selectionRect.bottomLeftScaler.bounds.contains(event.point)) {
            return canvas.css({
              cursor: "sw-resize"
            });
          } else if (selectedTool.selectionRect.removeButton && selectedTool.selectionRect.removeButton.bounds.contains(event.point)) {
            return canvas.css({
              cursor: "pointer"
            });
          }
        }
      };

      Room.prototype.onMouseDown = function(canvas, event) {
        var arrow, _i, _j, _results;
        event.point = this.applyCurrentScale(event.point);
        $("#removeSelected").addClass("disabled");
        if (this.items.selected() && this.items.selected().selectionRect) {
          this.items.selected().selectionRect.remove();
        }
        this.opts.tool = null;
        switch (this.opts.tooltype) {
          case 'line':
            return this.items.create(new Path());
          case 'highligher':
            return this.items.create(new Path(), {
              color: this.opts.color,
              width: 15,
              opacity: 0.7
            });
          case 'straightline':
            this.items.create(new Path());
            _results = [];
            for (_i = 0; _i <= 1; _i++) {
              _results.push(this.opts.tool.add(event.point));
            }
            return _results;
            break;
          case 'arrow':
            arrow = new Path();
            arrow.arrow = arrow;
            this.items.create(arrow);
            for (_j = 0; _j <= 1; _j++) {
              this.opts.tool.add(event.point);
            }
            return this.opts.tool.lineStart = event.point;
          case "select":
            this.items.testSelect(event.point);
            return this.items.drawSelectRect(event.point);
        }
      };

      Room.prototype.onMouseDrag = function(canvas, event) {
        var arrow, arrowGroup, deltaPoint, h, rectangle, scalersSelected, triangle, w, x, y;
        event.point = this.applyCurrentScale(event.point);
        deltaPoint = event.downPoint.subtract(event.point);
        switch (this.opts.tooltype) {
          case 'line':
            this.opts.tool.add(event.point);
            return this.opts.tool.smooth();
          case 'highligher':
            this.opts.tool.add(event.point);
            return this.opts.tool.smooth();
          case 'circle':
            rectangle = new Rectangle(event.point.x, event.point.y, deltaPoint.x, deltaPoint.y);
            this.items.create(new Path.Oval(rectangle));
            return this.opts.tool.removeOnDrag();
          case 'rectangle':
            rectangle = new Rectangle(event.point.x, event.point.y, deltaPoint.x, deltaPoint.y);
            this.items.create(new Path.Rectangle(rectangle));
            return this.opts.tool.removeOnDrag();
          case 'comment':
            if (deltaPoint.x < 0 && deltaPoint.y < 0) {
              x = event.downPoint.x;
              y = event.downPoint.y;
              w = Math.abs(deltaPoint.x);
              h = Math.abs(deltaPoint.y);
            } else {
              x = event.point.x;
              y = event.point.y;
              w = deltaPoint.x;
              h = deltaPoint.y;
            }
            rectangle = new Path.RoundRectangle(x, y, w, h, this.comments.COMMENT_RECTANGLE_ROUNDNESS, this.comments.COMMENT_RECTANGLE_ROUNDNESS);
            rectangle.isCommentRect = true;
            this.items.create(rectangle, this.comments.COMMENT_STYLE);
            return this.opts.tool.removeOnDrag();
          case 'straightline':
            return this.opts.tool.lastSegment.point = event.point;
          case 'arrow':
            arrow = this.opts.tool.arrow;
            arrow.lastSegment.point = event.point;
            arrowGroup = new Group([arrow]);
            arrowGroup.arrow = arrow;
            arrowGroup.drawTriangle = function() {
              var triangle, vector;
              vector = this.arrow.lastSegment.point - this.arrow.segments[0].point;
              vector = vector.normalize(10);
              if (this.triangle) {
                this.triangle.segments[0].point = this.arrow.lastSegment.point + vector.rotate(135);
                this.triangle.segments[1].point = this.arrow.lastSegment.point;
                this.triangle.segments[2].point = this.arrow.lastSegment.point + vector.rotate(-135);
              } else {
                triangle = new Path([this.arrow.lastSegment.point + vector.rotate(135), this.arrow.lastSegment.point, this.arrow.lastSegment.point + vector.rotate(-135)]);
                this.triangle = triangle;
                this.addChild(triangle);
              }
              return this.triangle;
            };
            triangle = arrowGroup.drawTriangle();
            this.items.create(triangle);
            this.opts.tool = arrowGroup;
            return triangle.removeOnDrag();
          case 'pan':
            return this.items.pan(event.delta.x, event.delta.y);
          case 'select':
            scalersSelected = this.items.selected() && this.items.selected().scalersSelected;
            if (scalersSelected) {
              this.items.sacleSelected(event);
            } else {
              this.items.translateSelected(event.delta);
            }
            if (this.items.selected().commentMin) {
              return this.comments.redrawArrow(this.items.selected().commentMin);
            }
        }
      };

      Room.prototype.onMouseUp = function(canvas, event) {
        var commentMin, commentRect, tooltype;
        event.point = this.applyCurrentScale(event.point);
        tooltype = this.opts.tooltype;
        switch (tooltype) {
          case 'line':
            this.opts.tool.add(event.point);
            this.opts.tool.simplify(10);
            break;
          case 'highligher':
            this.opts.tool.add(event.point);
            this.opts.tool.simplify(10);
            break;
          case "comment":
            commentRect = this.opts.tool && this.opts.tool.isCommentRect ? this.opts.tool : null;
            commentMin = this.comments.create(event.point.x, event.point.y, commentRect);
            if (commentRect) {
              commentRect.commentMin = commentMin;
            }
        }
        switch (tooltype) {
          case 'straightline':
          case 'arrow':
          case 'circle':
          case 'rectangle':
          case 'line':
          case 'highligher':
            this.opts.tool.eligible = true;
            this.history.add();
            this.opts.tool.elementId = this.generateId();
            this.socket.emit("elementUpdate", this.socketHelper.prepareElementToSend(this.opts.tool));
            break;
          case "comment":
            if (commentRect) {
              this.opts.tool.eligible = true;
              this.history.add();
            } else {
              this.history.add({
                type: "comment",
                commentMin: commentMin,
                eligible: true
              });
            }
            commentMin.elementId = this.generateId();
            this.socket.emit("commentUpdate", this.socketHelper.prepareCommentToSend(commentMin));
            break;
          case 'select':
            if (this.items.selected()) {
              this.socket.emit("elementUpdate", this.socketHelper.prepareElementToSend(this.items.selected()));
            }
        }
        if (tooltype === 'comment') {
          this.opts.tooltype = "select";
        }
        return this.canvas.updateSelectedThumb();
      };

      Room.prototype.applyCurrentScale = function(point) {
        return point.transform(new Matrix(1 / this.opts.currentScale, 0, 0, 1 / this.opts.currentScale, 0, 0));
      };

      Room.prototype.generateId = function() {
        return $("#uid").val() + new Date().getTime();
      };

      Room.prototype.redraw = function() {
        return paper.view.draw();
      };

      Room.prototype.redrawWithThumb = function() {
        this.redraw();
        return this.canvas.updateSelectedThumb();
      };

      return Room;

    })();
    room = new Room;
    return $.extend(App.room, room);
  });

  $(function() {
    var key, tool;
    if (!currentPage("projects/show")) {
      return;
    }
    for (key in paper) {
      if (!/^(version|_id|load)/.test(key) && !(window[key] != null)) {
        window[key] = paper[key];
      }
    }
    paper.setup($('#myCanvas')[0]);
    tool = new paper.Tool();
    tool.onMouseDown = function(event) {
      return App.room.onMouseDown($("#myCanvas"), event);
    };
    tool.onMouseDrag = function(event) {
      return App.room.onMouseDrag($("#myCanvas"), event);
    };
    tool.onMouseUp = function(event) {
      return App.room.onMouseUp($("#myCanvas"), event);
    };
    tool.onMouseMove = function(event) {
      return App.room.onMouseMove($("#myCanvas"), event);
    };
    App.room.init();
    window.room = App.room;
    window.opts = App.room.opts;
    return paper.view.setViewSize(Rectangle.create(0, 0, $("body").width(), $("body").height()).getSize());
  });

}).call(this);
