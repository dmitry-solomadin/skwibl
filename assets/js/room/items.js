// Generated by CoffeeScript 1.4.0
(function() {

  $(function() {
    var RoomItems;
    RoomItems = (function() {

      function RoomItems() {
        this.removeImg = new Image();
        this.removeImg.src = "/images/remove.png";
      }

      RoomItems.prototype.create = function(tool, settings) {
        if (!settings) {
          settings = {};
        }
        if (!settings.justCreate) {
          opts.tool = tool;
        }
        tool.strokeJoin = "round";
        opts.tool.strokeColor = settings.color ? settings.color : opts.color;
        opts.tool.strokeWidth = settings.width ? settings.width : opts.defaultWidth;
        if (settings.fillColor) {
          opts.tool.fillColor = settings.fillColor;
        }
        opts.tool.opacity = settings.opacity ? settings.opacity : opts.opacity;
        return opts.tool.dashArray = settings.dashArray ? settings.dashArray : void 0;
      };

      RoomItems.prototype.removeSelected = function() {
        if (this.selected()) {
          room.history.add({
            type: "remove",
            tool: this.selected(),
            eligible: true
          });
          this.selected().opacity = 0;
          room.socket.emit("elementRemove", this.selected().elementId);
          this.unselect();
          return room.redrawWithThumb();
        }
      };

      RoomItems.prototype.translateSelected = function(deltaPoint) {
        if (this.selected()) {
          this.selected().translate(deltaPoint);
          if (this.selected().selectionRect) {
            this.selected().selectionRect.translate(deltaPoint);
          }
          return room.redraw();
        }
      };

      RoomItems.prototype.unselectIfSelected = function(elementId) {
        if (this.selected() && this.selected().selectionRect && this.selected().elementId === elementId) {
          return this.unselect();
        }
      };

      RoomItems.prototype.unselect = function() {
        if (this.selected() && this.selected().selectionRect) {
          this.selected().selectionRect.remove();
        }
        return this.setSelected(null);
      };

      RoomItems.prototype.pan = function(dx, dy) {
        var element, _i, _len, _ref, _results;
        _ref = opts.historytools.allHistory;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          element = _ref[_i];
          if (element.commentMin) {
            _results.push(room.comments.translate(element.commentMin, dx, dy));
          } else if (!element.type && element.translate) {
            _results.push(element.translate(new Point(dx, dy)));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };

      RoomItems.prototype.selected = function() {
        return opts.selectedTool;
      };

      RoomItems.prototype.setSelected = function(selectedTool) {
        return opts.selectedTool = selectedTool;
      };

      RoomItems.prototype.testSelect = function(point) {
        var alreadySelected, element, previousSelectedTool, selectTimeDelta, selected, _i, _len, _ref;
        selectTimeDelta = opts.selectTime ? new Date().getTime() - opts.selectTime : void 0;
        opts.selectTime = new Date().getTime();
        alreadySelected = this.selected() && this.selected().selectionRect;
        selected = false;
        if (alreadySelected) {
          if (room.helper.elementInArrayContainsPoint(this.selected().selectionRect.scalers, point) || (this.selected().selectionRect.removeButton && this.selected().selectionRect.removeButton.bounds.contains(point))) {
            selected = true;
          }
        }
        if (selectTimeDelta > 750 && alreadySelected && this.selected().selectionRect.bounds.contains(point)) {
          selected = true;
        }
        if (!selected) {
          previousSelectedTool = this.selected();
          _ref = room.history.getSelectableTools();
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            element = _ref[_i];
            if (element.isImage || element.type) {
              continue;
            }
            if (element.bounds.contains(point)) {
              this.setSelected(element);
              selected = true;
            }
            if (selectTimeDelta < 750 && this.selected() && previousSelectedTool) {
              if (this.selected().id === previousSelectedTool.id) {
                continue;
              } else {
                break;
              }
            }
          }
        }
        if (!selected) {
          return this.setSelected(null);
        }
      };

      RoomItems.prototype.drawSelectRect = function(point) {
        if (this.selected()) {
          this.selected().selectionRect = this.createSelectionRectangle();
          $("#removeSelected").removeClass("disabled");
          this.selected().scalersSelected = true;
          if (this.selected().selectionRect.topLeftScaler.bounds.contains(point)) {
            this.selected().scaleZone = {
              zx: -1,
              zy: -1,
              point: this.selected().bounds.bottomRight
            };
          } else if (this.selected().selectionRect.bottomRightScaler.bounds.contains(point)) {
            this.selected().scaleZone = {
              zx: 1,
              zy: 1,
              point: this.selected().bounds.topLeft
            };
          } else if (this.selected().selectionRect.topRightScaler.bounds.contains(point)) {
            this.selected().scaleZone = {
              zx: 1,
              zy: -1,
              point: this.selected().bounds.bottomLeft
            };
          } else if (this.selected().selectionRect.bottomLeftScaler.bounds.contains(point)) {
            this.selected().scaleZone = {
              zx: -1,
              zy: 1,
              point: this.selected().bounds.topRight
            };
          } else {
            this.selected().scalersSelected = false;
          }
          if (this.selected().selectionRect.removeButton && this.selected().selectionRect.removeButton.bounds.contains(point)) {
            return this.removeSelected();
          }
        }
      };

      RoomItems.prototype.createSelectionRectangle = function() {
        var addBound, bottomLeftScaler, bottomRightScaler, bounds, dashArray, halfWidth, removeButton, selectRect, selectionRectGroup, topLeftScaler, topRightScaler, width;
        bounds = this.selected().bounds;
        addBound = parseInt(this.selected().strokeWidth / 2);
        selectRect = new Path.Rectangle(bounds.x - addBound, bounds.y - addBound, bounds.width + (addBound * 2), bounds.height + (addBound * 2));
        width = 8;
        halfWidth = width / 2;
        topLeftScaler = new Path.Oval(new Rectangle(bounds.x - addBound - halfWidth, bounds.y - addBound - halfWidth, width, width));
        bottomRightScaler = new Path.Oval(new Rectangle(bounds.x + bounds.width + addBound - halfWidth, bounds.y + bounds.height + addBound - halfWidth, width, width));
        topRightScaler = new Path.Oval(new Rectangle(bounds.x + bounds.width + addBound - halfWidth, bounds.y - addBound - halfWidth, width, width));
        bottomLeftScaler = new Path.Oval(new Rectangle(bounds.x - addBound - halfWidth, bounds.y + bounds.height + addBound - halfWidth, width, width));
        if (!this.selected().commentMin) {
          removeButton = new Raster(this.removeImg);
          removeButton.position = new Point(selectRect.bounds.x + selectRect.bounds.width + 12, selectRect.bounds.y - 12);
        }
        selectionRectGroup = new Group([selectRect, topLeftScaler, bottomRightScaler, topRightScaler, bottomLeftScaler]);
        selectionRectGroup.theRect = selectRect;
        selectionRectGroup.topLeftScaler = topLeftScaler;
        selectionRectGroup.bottomRightScaler = bottomRightScaler;
        selectionRectGroup.topRightScaler = topRightScaler;
        selectionRectGroup.bottomLeftScaler = bottomLeftScaler;
        selectionRectGroup.scalers = [topLeftScaler, bottomRightScaler, topRightScaler, bottomLeftScaler];
        if (!this.selected().commentMin) {
          selectionRectGroup.removeButton = removeButton;
          selectionRectGroup.addChild(removeButton);
        }
        dashArray = [3, 3];
        this.create(selectRect, {
          color: "#a0a0aa",
          width: 0.5,
          opacity: 1,
          dashArray: dashArray
        });
        this.create(topLeftScaler, {
          color: "#202020",
          width: 1,
          opacity: 1,
          fillColor: "white"
        });
        this.create(bottomRightScaler, {
          color: "#202020",
          width: 1,
          opacity: 1,
          fillColor: "white"
        });
        this.create(topRightScaler, {
          color: "#202020",
          width: 1,
          opacity: 1,
          fillColor: "white"
        });
        this.create(bottomLeftScaler, {
          color: "#202020",
          width: 1,
          opacity: 1,
          fillColor: "white"
        });
        if (!this.selected().commentMin) {
          this.create(removeButton);
        }
        return selectionRectGroup;
      };

      RoomItems.prototype.sacleSelected = function(event) {
        var scaleFactors, scalePoint, scaleZone, sx, sy, transformMatrix, zx, zy;
        scaleZone = this.getReflectZone(this.selected(), event.point.x, event.point.y);
        if (scaleZone) {
          this.selected().scaleZone = scaleZone;
        } else {
          scaleZone = this.selected().scaleZone;
        }
        zx = scaleZone.zx;
        zy = scaleZone.zy;
        scalePoint = scaleZone.point;
        scaleFactors = this.getScaleFactors(this.selected(), zx, zy, event.delta.x, event.delta.y);
        sx = scaleFactors.sx;
        sy = scaleFactors.sy;
        transformMatrix = new Matrix().scale(sx, sy, scalePoint);
        if (transformMatrix._d === 0 || transformMatrix._a === 0) {
          return;
        }
        if (this.selected().arrow) {
          this.selected().arrow.scale(sx, sy, scalePoint);
          this.selected().drawTriangle();
        } else {
          this.selected().transform(transformMatrix);
        }
        this.selected().selectionRect.remove();
        return this.selected().selectionRect = this.createSelectionRectangle();
      };

      RoomItems.prototype.getScaleFactors = function(item, zx, zy, dx, dy) {
        var h, w;
        item = item.arrow ? item.arrow : item;
        w = item.bounds.width;
        h = item.bounds.height;
        if (zx === -1 && zy === -1) {
          return {
            sx: Math.abs((w - dx) / w),
            sy: Math.abs((h - dy) / h)
          };
        }
        if (zx === 1 && zy === -1) {
          return {
            sx: Math.abs((w + dx) / w),
            sy: Math.abs((h - dy) / h)
          };
        }
        if (zx === -1 && zy === 1) {
          return {
            sx: Math.abs((w - dx) / w),
            sy: Math.abs((h + dy) / h)
          };
        }
        if (zx === 1 && zy === 1) {
          return {
            sx: Math.abs((w + dx) / w),
            sy: Math.abs((h + dy) / h)
          };
        }
      };

      RoomItems.prototype.getReflectZone = function(item, x, y) {
        var center, cx, cy, dzx, dzy, h, itemToScale, w, zone;
        itemToScale = item.arrow ? item.arrow : item;
        if (itemToScale.bounds.contains(x, y)) {
          return null;
        }
        w = itemToScale.bounds.width;
        h = itemToScale.bounds.height;
        center = new Point(itemToScale.bounds.topLeft.x + (w / 2), itemToScale.bounds.topLeft.y + (h / 2));
        cx = center.x;
        cy = center.y;
        if (x <= cx && y <= cy) {
          zone = {
            zx: -1,
            zy: -1,
            point: itemToScale.bounds.bottomRight
          };
        } else if (x >= cx && y <= cy) {
          zone = {
            zx: 1,
            zy: -1,
            point: itemToScale.bounds.bottomLeft
          };
        } else if (x <= cx && y >= cy) {
          zone = {
            zx: -1,
            zy: 1,
            point: itemToScale.bounds.topRight
          };
        } else if (x >= cx && y >= cy) {
          zone = {
            zx: 1,
            zy: 1,
            point: itemToScale.bounds.topLeft
          };
        }
        dzx = zone.zx + item.scaleZone.zx;
        dzy = zone.zy + item.scaleZone.zy;
        if (dzx === 0 && dzy === 0 && w < 3 && h < 3) {
          itemToScale.scale(-1, -1);
          return zone;
        } else if (dzx === 0 && dzy !== 0 && w < 3) {
          itemToScale.scale(-1, 1);
          return zone;
        } else if (dzy === 0 && dzx !== 0 && h < 3) {
          itemToScale.scale(1, -1);
          return zone;
        } else {
          return null;
        }
      };

      return RoomItems;

    })();
    return App.room.items = new RoomItems;
  });

}).call(this);
