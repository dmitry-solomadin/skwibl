// Generated by CoffeeScript 1.4.0
(function() {

  $(function() {
    var Room, room;
    Room = (function() {

      function Room() {
        this.opts = {};
        this.savedOpts = new Array;
        this.defaultOpts = {
          tooltype: 'line',
          color: '#404040',
          defaultWidth: 2,
          currentScale: 1,
          nextId: 1,
          opacity: 1
        };
      }

      Room.prototype.init = function() {
        var canvas;
        this.initOpts();
        this.savedOpts.push(this.opts);
        $("#toolSelect > li, #panTool, #selectTool").on("click", function() {
          return App.room.opts.tooltype = $(this).data("tooltype");
        });
        $('.color').click(function() {
          $('.color').removeClass('activen');
          App.room.opts.color = $(this).attr('data-color');
          return $(this).addClass('activen');
        });
        $(document).on("click", "#canvasSelectDiv a", function() {
          App.room.canvas.selectThumb(this);
          return false;
        });
        this.helper.initUploader();
        this.helper.initHotkeys();
        canvas = $("#myCanvas")[0];
        canvas.onselectstart = function() {
          return false;
        };
        canvas.onmousedown = function() {
          return false;
        };
        return false;
      };

      Room.prototype.initOpts = function() {
        this.opts = {};
        App.room.opts = this.opts;
        $.extend(this.opts, this.defaultOpts);
        return this.opts.historytools = {
          eligibleHistory: new Array,
          allHistory: new Array
        };
      };

      Room.prototype.onMouseMove = function(canvas, event) {
        var selectedTool;
        event.point = event.point.transform(new Matrix(1 / this.opts.currentScale, 0, 0, 1 / this.opts.currentScale, 0, 0));
        $(canvas).css({
          cursor: "default"
        });
        selectedTool = this.opts.selectedTool;
        if (selectedTool && selectedTool.selectionRect) {
          if (selectedTool.selectionRect.bottomRightScaler.bounds.contains(event.point)) {
            return $(canvas).css({
              cursor: "se-resize"
            });
          } else if (selectedTool.selectionRect.topLeftScaler.bounds.contains(event.point)) {
            return $(canvas).css({
              cursor: "nw-resize"
            });
          } else if (selectedTool.selectionRect.topRightScaler.bounds.contains(event.point)) {
            return $(canvas).css({
              cursor: "ne-resize"
            });
          } else if (selectedTool.selectionRect.bottomLeftScaler.bounds.contains(event.point)) {
            return $(canvas).css({
              cursor: "sw-resize"
            });
          } else if (selectedTool.selectionRect.removeButton && selectedTool.selectionRect.removeButton.bounds.contains(event.point)) {
            return $(canvas).css({
              cursor: "pointer"
            });
          }
        }
      };

      Room.prototype.onMouseDown = function(canvas, event) {
        var arrow;
        event.point = event.point.transform(new Matrix(1 / this.opts.currentScale, 0, 0, 1 / this.opts.currentScale, 0, 0));
        $("#removeSelected").addClass("disabled");
        if (this.opts.selectedTool && this.opts.selectedTool.selectionRect) {
          this.opts.selectedTool.selectionRect.remove();
        }
        this.opts.commentRect = null;
        if (this.opts.tooltype === 'line') {
          this.items.create(new Path());
        } else if (this.opts.tooltype === 'highligher') {
          this.items.create(new Path(), {
            color: this.opts.color,
            width: 15,
            opacity: 0.7
          });
        } else if (this.opts.tooltype === 'straightline') {
          this.items.create(new Path());
          if (this.opts.tool.segments.length === 0) {
            this.opts.tool.add(event.point);
          }
          this.opts.tool.add(event.point);
        } else if (this.opts.tooltype === 'arrow') {
          arrow = new Path();
          arrow.arrow = arrow;
          this.items.create(arrow);
          if (this.opts.tool.segments.length === 0) {
            this.opts.tool.add(event.point);
          }
          this.opts.tool.add(event.point);
          this.opts.tool.lineStart = event.point;
        } else if (this.opts.tooltype === "select") {
          this.items.testSelect(event.point);
          this.items.drawSelectRect(event.point);
        }
        if (this.opts.tooltype === 'line' || this.opts.tooltype === 'highligher') {
          this.opts.tool.eligible = true;
          return this.history.add();
        }
      };

      Room.prototype.onMouseDrag = function(canvas, event) {
        var arrow, arrowGroup, commentRect, deltaPoint, dx, dy, element, h, rectangle, scaleFactors, scalePoint, scaleZone, sx, sy, tool, triangle, w, x, y, zx, zy, _i, _len, _ref, _results;
        event.point = event.point.transform(new Matrix(1 / this.opts.currentScale, 0, 0, 1 / this.opts.currentScale, 0, 0));
        deltaPoint = event.downPoint.subtract(event.point);
        if (this.opts.tooltype === 'line') {
          this.opts.tool.add(event.point);
          return this.opts.tool.smooth();
        } else if (this.opts.tooltype === 'highligher') {
          this.opts.tool.add(event.point);
          return this.opts.tool.smooth();
        } else if (this.opts.tooltype === 'circle') {
          rectangle = new Rectangle(event.point.x, event.point.y, deltaPoint.x, deltaPoint.y);
          this.items.create(new Path.Oval(rectangle));
          return this.opts.tool.removeOnDrag();
        } else if (this.opts.tooltype === 'rectangle') {
          rectangle = new Rectangle(event.point.x, event.point.y, deltaPoint.x, deltaPoint.y);
          this.items.create(new Path.Rectangle(rectangle));
          return this.opts.tool.removeOnDrag();
        } else if (this.opts.tooltype === 'comment') {
          if (deltaPoint.x < 0 && deltaPoint.y < 0) {
            x = event.downPoint.x;
            y = event.downPoint.y;
            w = Math.abs(deltaPoint.x);
            h = Math.abs(deltaPoint.y);
          } else {
            x = event.point.x;
            y = event.point.y;
            w = deltaPoint.x;
            h = deltaPoint.y;
          }
          rectangle = new Path.RoundRectangle(x, y, w, h, this.comments.COMMENT_RECTANGLE_ROUNDNESS, this.comments.COMMENT_RECTANGLE_ROUNDNESS);
          this.opts.commentRect = rectangle;
          this.items.create(rectangle, this.comments.COMMENT_STYLE);
          return this.opts.tool.removeOnDrag();
        } else if (this.opts.tooltype === 'straightline') {
          return this.opts.tool.lastSegment.point = event.point;
        } else if (this.opts.tooltype === 'arrow') {
          arrow = this.opts.tool.arrow;
          arrow.lastSegment.point = event.point;
          arrowGroup = new Group([arrow]);
          arrowGroup.arrow = arrow;
          arrowGroup.drawTriangle = function() {
            var triangle, vector;
            vector = this.arrow.lastSegment.point - this.arrow.segments[0].point;
            vector = vector.normalize(10);
            if (this.triangle) {
              this.triangle.segments[0].point = this.arrow.lastSegment.point + vector.rotate(135);
              this.triangle.segments[1].point = this.arrow.lastSegment.point;
              this.triangle.segments[2].point = this.arrow.lastSegment.point + vector.rotate(-135);
            } else {
              triangle = new Path([this.arrow.lastSegment.point + vector.rotate(135), this.arrow.lastSegment.point, this.arrow.lastSegment.point + vector.rotate(-135)]);
              this.triangle = triangle;
              this.addChild(triangle);
            }
            return this.triangle;
          };
          triangle = arrowGroup.drawTriangle();
          this.items.create(triangle);
          this.opts.tool = arrowGroup;
          return triangle.removeOnDrag();
        } else if (this.opts.tooltype === 'pan') {
          _ref = this.opts.historytools.allHistory;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            element = _ref[_i];
            if (element.commentMin) {
              commentRect = element.type !== "comment";
              dx = this.opts.currentScale * event.delta.x;
              dy = this.opts.currentScale * event.delta.y;
              element.commentMin.css({
                top: element.commentMin.position().top + dy,
                left: element.commentMin.position().left + dx
              });
              element.commentMin[0].arrow.translate(event.delta);
              element.commentMin[0].$maximized.css({
                top: element.commentMin[0].$maximized.position().top + dy,
                left: element.commentMin[0].$maximized.position().left + dx
              });
              if (commentRect) {
                _results.push(element.translate(event.delta));
              } else {
                _results.push(void 0);
              }
            } else if (!element.type && element.translate) {
              _results.push(element.translate(event.delta));
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        } else if (this.opts.tooltype === 'select') {
          if (this.opts.selectedTool && this.opts.selectedTool.scalersSelected) {
            tool = this.opts.selectedTool;
            scaleZone = this.items.getReflectZone(tool, event.point.x, event.point.y);
            if (scaleZone) {
              tool.scaleZone = scaleZone;
            } else {
              scaleZone = tool.scaleZone;
            }
            zx = scaleZone.zx;
            zy = scaleZone.zy;
            scalePoint = scaleZone.point;
            dx = event.delta.x;
            dy = event.delta.y;
            scaleFactors = this.items.getScaleFactors(tool, zx, zy, dx, dy);
            sx = scaleFactors.sx;
            sy = scaleFactors.sy;
            this.items.doScale(tool, sx, sy, scalePoint);
            tool.selectionRect.remove();
            tool.selectionRect = this.items.createSelectionRectangle(tool);
          } else {
            this.items.translateSelected(event.delta);
          }
          if (this.opts.selectedTool.commentMin) {
            return this.comments.redrawArrow(this.opts.selectedTool.commentMin);
          }
        }
      };

      Room.prototype.onMouseUp = function(canvas, event) {
        var commentMin;
        event.point = event.point.transform(new Matrix(1 / this.opts.currentScale, 0, 0, 1 / this.opts.currentScale, 0, 0));
        if (this.opts.tooltype === 'line') {
          this.opts.tool.add(event.point);
          this.opts.tool.simplify(10);
        }
        if (this.opts.tooltype === 'highligher') {
          this.opts.tool.add(event.point);
          this.opts.tool.simplify(10);
        }
        if (this.opts.tooltype === "comment") {
          commentMin = this.comments.create(event.point.x, event.point.y, this.opts.commentRect);
          if (this.opts.commentRect) {
            this.opts.commentRect.commentMin = commentMin;
          }
        }
        if (this.opts.tool) {
          this.opts.tool.tooltype = this.opts.tooltype;
        }
        if (this.opts.tooltype === 'straightline' || this.opts.tooltype === 'arrow' || this.opts.tooltype === 'circle' || this.opts.tooltype === 'rectangle') {
          this.opts.tool.eligible = true;
          this.history.add();
        }
        if (this.opts.tooltype === 'comment') {
          if (this.opts.commentRect) {
            this.opts.tool.eligible = true;
            this.history.add();
          } else {
            this.history.add({
              type: "comment",
              commentMin: commentMin,
              eligible: true
            });
          }
        }
        if (this.opts.tooltype === 'straightline' || this.opts.tooltype === 'arrow' || this.opts.tooltype === 'circle' || this.opts.tooltype === 'rectangle' || this.opts.tooltype === 'line' || this.opts.tooltype === 'highligher') {
          this.opts.tool.elementId = this.getNextIdAndIncrement();
          this.socket.emit("elementUpdate", this.socketHelper.prepareElementToSend(this.opts.tool));
          this.socket.emit("nextId");
        } else if (this.opts.tooltype === "comment") {
          commentMin.elementId = this.getNextIdAndIncrement();
          this.socket.emit("commentUpdate", this.socketHelper.prepareCommentToSend(commentMin));
          this.socket.emit("nextId");
        } else if (this.opts.tooltype === 'select' && this.opts.selectedTool) {
          this.socket.emit("elementUpdate", this.socketHelper.prepareElementToSend(this.opts.selectedTool));
        }
        if (this.opts.tooltype === 'comment') {
          this.opts.tooltype = "select";
        }
        return this.canvas.updateSelectedThumb();
      };

      Room.prototype.getNextIdAndIncrement = function() {
        var prevId;
        prevId = this.opts.nextId;
        this.opts.nextId = this.opts.nextId + 1;
        return prevId;
      };

      Room.prototype.redraw = function() {
        return paper.view.draw();
      };

      Room.prototype.redrawWithThumb = function() {
        this.redraw();
        return this.canvas.updateSelectedThumb();
      };

      return Room;

    })();
    room = new Room;
    return $.extend(App.room, room);
  });

  $(function() {
    var key, tool;
    if (!currentPage("projects/show")) {
      return;
    }
    for (key in paper) {
      if (!/^(version|_id|load)/.test(key) && !(window[key] != null)) {
        window[key] = paper[key];
      }
    }
    paper.setup($('#myCanvas')[0]);
    tool = new paper.Tool();
    tool.onMouseDown = function(event) {
      return App.room.onMouseDown($("#myCanvas"), event);
    };
    tool.onMouseDrag = function(event) {
      return App.room.onMouseDrag($("#myCanvas"), event);
    };
    tool.onMouseUp = function(event) {
      return App.room.onMouseUp($("#myCanvas"), event);
    };
    tool.onMouseMove = function(event) {
      return App.room.onMouseMove($("#myCanvas"), event);
    };
    App.room.init();
    return paper.view.setViewSize(Rectangle.create(0, 0, $("body").width(), $("body").height()).getSize());
  });

}).call(this);
