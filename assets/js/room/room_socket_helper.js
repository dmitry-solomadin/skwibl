// Generated by CoffeeScript 1.4.0
(function() {

  $(function() {
    var RoomSocketHelper;
    RoomSocketHelper = (function() {

      function RoomSocketHelper() {
        var socket,
          _this = this;
        socket = io.connect('/canvas', window.copt);
        App.room.socket = socket;
        socket.on('elementUpdate', function(data) {
          return _this.addOrUpdateElement(data.message, false);
        });
        socket.on('elementRemove', function(data) {
          return _this.socketRemoveElement(data.message);
        });
        socket.on('commentUpdate', function(data) {
          return _this.addOrUpdateComment(data.message, false);
        });
        socket.on('commentRemove', function(data) {
          return _this.socketRemoveComment(data.message);
        });
        socket.on('commentText', function(data) {
          return _this.addOrUpdateCommentText(data.message);
        });
        socket.on('eraseCanvas', function() {
          room.canvas.erase();
          return room.redrawWithThumb();
        });
        socket.on('nextId', function() {
          return opts.nextId = opts.nextId + 1;
        });
      }

      RoomSocketHelper.prototype.addOrUpdateCommentText = function(data) {
        var foundComment;
        foundComment = room.helper.findByElementId(data.elementId);
        return room.comments.addCommentText(foundComment.commentMin, data.text, false);
      };

      RoomSocketHelper.prototype.addOrUpdateComment = function(data, initial) {
        var createNewComment, foundComment, updateComment,
          _this = this;
        updateComment = function(comment, updatedComment) {
          comment.commentMin.css({
            left: updatedComment.min.x,
            top: updatedComment.min.y
          });
          comment.commentMin[0].$maximized.css({
            left: updatedComment.max.x,
            top: updatedComment.max.y
          });
          return room.comments.redrawArrow(comment.commentMin);
        };
        createNewComment = function(comment) {
          var commentMin, rect;
          if (comment.rect) {
            rect = new Path.RoundRectangle(comment.rect.x, comment.rect.y, comment.rect.w, comment.rect.h, 8, 8);
            room.items.create(rect, room.comments.COMMENT_STYLE);
          }
          commentMin = room.comments.create(comment.min.x, comment.min.y, rect, comment.max);
          commentMin.elementId = comment.elementId;
          if (rect) {
            rect.commentMin = commentMin;
            rect.eligible = false;
            return room.history.add(rect);
          } else {
            return room.history.add({
              type: "comment",
              commentMin: commentMin,
              eligible: false
            });
          }
        };
        if (initial) {
          $(data).each(function() {
            return createNewComment(this);
          });
        } else {
          foundComment = room.helper.findByElementId(data.elementId);
          if (foundComment) {
            updateComment(foundComment, data);
          } else {
            createNewComment(data);
          }
        }
        return room.redrawWithThumb();
      };

      RoomSocketHelper.prototype.socketRemoveElement = function(data) {
        room.helper.findByElementId(data).remove();
        room.items.unselectIfSelected(data);
        return room.redrawWithThumb();
      };

      RoomSocketHelper.prototype.socketRemoveComment = function(data) {
        var commentMin, element;
        element = room.helper.findByElementId(data);
        commentMin = element.commentMin;
        commentMin[0].$maximized.remove();
        commentMin[0].arrow.remove();
        if (commentMin[0].rect) {
          commentMin[0].rect.remove();
        }
        commentMin.remove();
        room.items.unselectIfSelected(data);
        return room.redrawWithThumb();
      };

      RoomSocketHelper.prototype.addOrUpdateElement = function(data, initial) {
        var createNewElement, createSegment, foundPath,
          _this = this;
        createSegment = function(x, y, ix, iy, ox, oy) {
          var firstPoint, handleIn, handleOut;
          handleIn = new Point(ix, iy);
          handleOut = new Point(ox, oy);
          firstPoint = new Point(x, y);
          return new Segment(firstPoint, handleIn, handleOut);
        };
        createNewElement = function(fromElement) {
          var path;
          path = new Path();
          $(fromElement.segments).each(function() {
            return path.addSegment(createSegment(this.x, this.y, this.ix, this.iy, this.ox, this.oy));
          });
          path.closed = fromElement.closed;
          path.elementId = fromElement.elementId;
          room.items.create(path, {
            color: fromElement.strokeColor,
            width: fromElement.strokeWidth,
            opacity: fromElement.opacity
          });
          path.eligible = false;
          return room.history.add(path);
        };
        if (initial) {
          $(data).each(function() {
            return createNewElement(this);
          });
        } else {
          foundPath = room.helper.findByElementId(data.elementId);
          if (foundPath) {
            room.items.unselectIfSelected(foundPath.elementId);
            foundPath.removeSegments();
            $(data.segments).each(function() {
              return foundPath.addSegment(createSegment(this.x, this.y, this.ix, this.iy, this.ox, this.oy));
            });
            if (foundPath.commentMin) {
              room.comments.redrawArrow(foundPath.commentMin);
            }
          } else {
            createNewElement(data);
          }
        }
        return room.redrawWithThumb();
      };

      RoomSocketHelper.prototype.prepareElementToSend = function(elementToSend) {
        var element, segment, _i, _len, _ref;
        element = {
          segments: [],
          elementId: elementToSend.commentMin ? elementToSend.commentMin.elementId : elementToSend.elementId,
          closed: elementToSend.closed,
          strokeColor: elementToSend.strokeColor.toCssString(),
          strokeWidth: elementToSend.strokeWidth,
          opacity: elementToSend.opacity
        };
        _ref = elementToSend.segments;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          segment = _ref[_i];
          element.segments.push({
            x: segment.point.x,
            y: segment.point.y,
            ix: segment.handleIn.x,
            iy: segment.handleIn.y,
            ox: segment.handleOut.x,
            oy: segment.handleOut.y
          });
        }
        return element;
      };

      RoomSocketHelper.prototype.prepareCommentToSend = function(commentMin) {
        var comment, commentMax, commentRect;
        comment = {
          min: {
            x: commentMin.position().left,
            y: commentMin.position().top
          },
          elementId: commentMin.elementId
        };
        commentMax = commentMin[0].$maximized[0];
        if (commentMax) {
          comment.max = {
            x: $(commentMax).position().left,
            y: $(commentMax).position().top
          };
        }
        commentRect = commentMin[0].rect;
        if (commentRect) {
          comment.rect = {
            x: commentRect.bounds.x,
            y: commentRect.bounds.y,
            w: commentRect.bounds.width,
            h: commentRect.bounds.height
          };
        }
        return comment;
      };

      return RoomSocketHelper;

    })();
    return App.room.socketHelper = new RoomSocketHelper;
  });

}).call(this);
